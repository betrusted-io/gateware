# ! [ doc = "Peripheral access API for SIMULATION microcontrollers (generated using svd2rust v0.17.0)\n\nYou can find an overview of the API [here].\n\n[here]: https://docs.rs/svd2rust/0.17.0/svd2rust/#peripheral-api" ]
# ! [ deny ( const_err ) ]
# ! [ deny ( dead_code ) ]
# ! [ deny ( improper_ctypes ) ]
# ! [ deny ( legacy_directory_ownership ) ]
# ! [ deny ( missing_docs ) ]
# ! [ deny ( no_mangle_generic_items ) ]
# ! [ deny ( non_shorthand_field_patterns ) ]
# ! [ deny ( overflowing_literals ) ]
# ! [ deny ( path_statements ) ]
# ! [ deny ( patterns_in_fns_without_body ) ]
# ! [ deny ( plugin_as_library ) ]
# ! [ deny ( private_in_public ) ]
# ! [ deny ( safe_extern_statics ) ]
# ! [ deny ( unconditional_recursion ) ]
# ! [ deny ( unions_with_drop_fields ) ]
# ! [ deny ( unused_allocation ) ]
# ! [ deny ( unused_comparisons ) ]
# ! [ deny ( unused_parens ) ]
# ! [ deny ( while_true ) ]
# ! [ allow ( non_camel_case_types ) ]
# ! [ allow ( non_snake_case ) ]
# ! [ no_std ]
extern crate riscv ; # [ cfg ( feature = "rt" ) ]
extern crate riscv_rt ; extern crate bare_metal ; extern crate vcell ; use core :: ops :: Deref ; use core :: marker :: PhantomData ; # [ doc ( hidden ) ]
pub mod interrupt { # [ doc = r"Enumeration of all the interrupts" ]
# [ derive ( Copy , Clone , Debug ) ]
# [ repr ( u8 ) ]
pub enum Interrupt { # [ doc = "0 - uart" ]
UART = 0 , # [ doc = "1 - timer0" ]
TIMER0 = 1 , } unsafe impl bare_metal :: Nr for Interrupt { # [ inline ( always ) ]
fn nr ( & self ) -> u8 { * self as u8 } } # [ derive ( Debug , Copy , Clone ) ]
pub struct TryFromInterruptError ( ( ) ) ; impl Interrupt { # [ inline ]
pub fn try_from ( value : u8 ) -> Result < Self , TryFromInterruptError > { match value { 0 => Ok ( Interrupt :: UART ) , 1 => Ok ( Interrupt :: TIMER0 ) , _ => Err ( TryFromInterruptError ( ( ) ) ) , } } } # [ cfg ( feature = "rt" ) ]
# [ macro_export ]
# [ doc = r" Assigns a handler to an interrupt" ]
# [ doc = r"" ]
# [ doc = r" This macro takes two arguments: the name of an interrupt and the path to the" ]
# [ doc = r" function that will be used as the handler of that interrupt. That function" ]
# [ doc = r" must have signature `fn()`." ]
# [ doc = r"" ]
# [ doc = r" Optionally, a third argument may be used to declare interrupt local data." ]
# [ doc = r" The handler will have exclusive access to these *local* variables on each" ]
# [ doc = r" invocation. If the third argument is used then the signature of the handler" ]
# [ doc = r" function must be `fn(&mut $NAME::Locals)` where `$NAME` is the first argument" ]
# [ doc = r" passed to the macro." ]
# [ doc = r"" ]
# [ doc = r" # Example" ]
# [ doc = r"" ]
# [ doc = r" ``` ignore" ]
# [ doc = r" interrupt!(TIM2, periodic);" ]
# [ doc = r"" ]
# [ doc = r" fn periodic() {" ]
# [ doc = r#"     print!(".");"# ]
# [ doc = r" }" ]
# [ doc = r"" ]
# [ doc = r" interrupt!(TIM3, tick, locals: {" ]
# [ doc = r"     tick: bool = false;" ]
# [ doc = r" });" ]
# [ doc = r"" ]
# [ doc = r" fn tick(locals: &mut TIM3::Locals) {" ]
# [ doc = r"     locals.tick = !locals.tick;" ]
# [ doc = r"" ]
# [ doc = r"     if locals.tick {" ]
# [ doc = r#"         println!("Tick");"# ]
# [ doc = r"     } else {" ]
# [ doc = r#"         println!("Tock");"# ]
# [ doc = r"     }" ]
# [ doc = r" }" ]
# [ doc = r" ```" ]
macro_rules ! interrupt { ( $ NAME : ident , $ path : path , locals : { $ ( $ lvar : ident : $ lty : ty = $ lval : expr ; ) * } ) => { # [ allow ( non_snake_case ) ]
mod $ NAME { pub struct Locals { $ ( pub $ lvar : $ lty , ) * } } # [ allow ( non_snake_case ) ]
# [ no_mangle ]
pub extern "C" fn $ NAME ( ) { let _ = $ crate :: interrupt :: Interrupt :: $ NAME ; static mut LOCALS : self :: $ NAME :: Locals = self :: $ NAME :: Locals { $ ( $ lvar : $ lval , ) * } ; let f : fn ( & mut self :: $ NAME :: Locals ) = $ path ; f ( unsafe { & mut LOCALS } ) ; } } ; ( $ NAME : ident , $ path : path ) => { # [ allow ( non_snake_case ) ]
# [ no_mangle ]
pub extern "C" fn $ NAME ( ) { let _ = $ crate :: interrupt :: Interrupt :: $ NAME ; let f : fn ( ) = $ path ; f ( ) ; } } } } pub use self :: interrupt :: Interrupt ; # [ allow ( unused_imports ) ]
use generic :: * ; # [ doc = r"Common register and bit access and modify traits" ]
pub mod generic { use core :: marker ; # [ doc = "This trait shows that register has `read` method" ]
# [ doc = "" ]
# [ doc = "Registers marked with `Writable` can be also `modify`'ed" ]
pub trait Readable { } # [ doc = "This trait shows that register has `write`, `write_with_zero` and `reset` method" ]
# [ doc = "" ]
# [ doc = "Registers marked with `Readable` can be also `modify`'ed" ]
pub trait Writable { } # [ doc = "Reset value of the register" ]
# [ doc = "" ]
# [ doc = "This value is initial value for `write` method." ]
# [ doc = "It can be also directly writed to register by `reset` method." ]
pub trait ResetValue { # [ doc = "Register size" ]
type Type ; # [ doc = "Reset value of the register" ]
fn reset_value ( ) -> Self :: Type ; } # [ doc = "This structure provides volatile access to register" ]
pub struct Reg < U , REG > { register : vcell :: VolatileCell < U > , _marker : marker :: PhantomData < REG > , } unsafe impl < U : Send , REG > Send for Reg < U , REG > { } impl < U , REG > Reg < U , REG > where Self : Readable , U : Copy { # [ doc = "Reads the contents of `Readable` register" ]
# [ doc = "" ]
# [ doc = "You can read the contents of a register in such way:" ]
# [ doc = "```ignore" ]
# [ doc = "let bits = periph.reg.read().bits();" ]
# [ doc = "```" ]
# [ doc = "or get the content of a particular field of a register." ]
# [ doc = "```ignore" ]
# [ doc = "let reader = periph.reg.read();" ]
# [ doc = "let bits = reader.field1().bits();" ]
# [ doc = "let flag = reader.field2().bit_is_set();" ]
# [ doc = "```" ]
# [ inline ( always ) ]
pub fn read ( & self ) -> R < U , Self > { R { bits : self . register . get ( ) , _reg : marker :: PhantomData } } } impl < U , REG > Reg < U , REG > where Self : ResetValue < Type = U > + Writable , U : Copy , { # [ doc = "Writes the reset value to `Writable` register" ]
# [ doc = "" ]
# [ doc = "Resets the register to its initial state" ]
# [ inline ( always ) ]
pub fn reset ( & self ) { self . register . set ( Self :: reset_value ( ) ) } } impl < U , REG > Reg < U , REG > where Self : ResetValue < Type = U > + Writable , U : Copy { # [ doc = "Writes bits to `Writable` register" ]
# [ doc = "" ]
# [ doc = "You can write raw bits into a register:" ]
# [ doc = "```ignore" ]
# [ doc = "periph.reg.write(|w| unsafe { w.bits(rawbits) });" ]
# [ doc = "```" ]
# [ doc = "or write only the fields you need:" ]
# [ doc = "```ignore" ]
# [ doc = "periph.reg.write(|w| w" ]
# [ doc = "    .field1().bits(newfield1bits)" ]
# [ doc = "    .field2().set_bit()" ]
# [ doc = "    .field3().variant(VARIANT)" ]
# [ doc = ");" ]
# [ doc = "```" ]
# [ doc = "Other fields will have reset value." ]
# [ inline ( always ) ]
pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W < U , Self > ) -> & mut W < U , Self > { self . register . set ( f ( & mut W { bits : Self :: reset_value ( ) , _reg : marker :: PhantomData } ) . bits ) ; } } impl < U , REG > Reg < U , REG > where Self : Writable , U : Copy + Default { # [ doc = "Writes Zero to `Writable` register" ]
# [ doc = "" ]
# [ doc = "Similar to `write`, but unused bits will contain 0." ]
# [ inline ( always ) ]
pub fn write_with_zero < F > ( & self , f : F ) where F : FnOnce ( & mut W < U , Self > ) -> & mut W < U , Self > { self . register . set ( f ( & mut W { bits : U :: default ( ) , _reg : marker :: PhantomData } ) . bits ) ; } } impl < U , REG > Reg < U , REG > where Self : Readable + Writable , U : Copy , { # [ doc = "Modifies the contents of the register" ]
# [ doc = "" ]
# [ doc = "E.g. to do a read-modify-write sequence to change parts of a register:" ]
# [ doc = "```ignore" ]
# [ doc = "periph.reg.modify(|r, w| unsafe { w.bits(" ]
# [ doc = "   r.bits() | 3" ]
# [ doc = ") });" ]
# [ doc = "```" ]
# [ doc = "or" ]
# [ doc = "```ignore" ]
# [ doc = "periph.reg.modify(|_, w| w" ]
# [ doc = "    .field1().bits(newfield1bits)" ]
# [ doc = "    .field2().set_bit()" ]
# [ doc = "    .field3().variant(VARIANT)" ]
# [ doc = ");" ]
# [ doc = "```" ]
# [ doc = "Other fields will have value they had before call `modify`." ]
# [ inline ( always ) ]
pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R < U , Self > , & 'w mut W < U , Self > ) -> & 'w mut W < U , Self > { let bits = self . register . get ( ) ; self . register . set ( f ( & R { bits , _reg : marker :: PhantomData } , & mut W { bits , _reg : marker :: PhantomData } ) . bits ) ; } } # [ doc = "Register/field reader" ]
# [ doc = "" ]
# [ doc = "Result of the [`read`](Reg::read) method of a register." ]
# [ doc = "Also it can be used in the [`modify`](Reg::read) method" ]
pub struct R < U , T > { pub ( crate ) bits : U , _reg : marker :: PhantomData < T > , } impl < U , T > R < U , T > where U : Copy { # [ doc = "Create new instance of reader" ]
# [ inline ( always ) ]
pub ( crate ) fn new ( bits : U ) -> Self { Self { bits , _reg : marker :: PhantomData , } } # [ doc = "Read raw bits from register/field" ]
# [ inline ( always ) ]
pub fn bits ( & self ) -> U { self . bits } } impl < U , T , FI > PartialEq < FI > for R < U , T > where U : PartialEq , FI : Copy + Into < U > { # [ inline ( always ) ]
fn eq ( & self , other : & FI ) -> bool { self . bits . eq ( & ( * other ) . into ( ) ) } } impl < FI > R < bool , FI > { # [ doc = "Value of the field as raw bits" ]
# [ inline ( always ) ]
pub fn bit ( & self ) -> bool { self . bits } # [ doc = "Returns `true` if the bit is clear (0)" ]
# [ inline ( always ) ]
pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } # [ doc = "Returns `true` if the bit is set (1)" ]
# [ inline ( always ) ]
pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } # [ doc = "Register writer" ]
# [ doc = "" ]
# [ doc = "Used as an argument to the closures in the [`write`](Reg::write) and [`modify`](Reg::modify) methods of the register" ]
pub struct W < U , REG > { # [ doc = "Writable bits" ]
pub ( crate ) bits : U , _reg : marker :: PhantomData < REG > , } impl < U , REG > W < U , REG > { # [ doc = "Writes raw bits to the register" ]
# [ inline ( always ) ]
pub unsafe fn bits ( & mut self , bits : U ) -> & mut Self { self . bits = bits ; self } } # [ doc = "Used if enumerated values cover not the whole range" ]
# [ derive ( Clone , Copy , PartialEq ) ]
pub enum Variant < U , T > { # [ doc = "Expected variant" ]
Val ( T ) , # [ doc = "Raw bits" ]
Res ( U ) , } } # [ doc = "TIMER0" ]
pub struct TIMER0 { _marker : PhantomData < * const ( ) > } unsafe impl Send for TIMER0 { } impl TIMER0 { # [ doc = r"Returns a pointer to the register block" ]
# [ inline ( always ) ]
pub const fn ptr ( ) -> * const timer0 :: RegisterBlock { 0x8200_5000 as * const _ } } impl Deref for TIMER0 { type Target = timer0 :: RegisterBlock ; # [ inline ( always ) ]
fn deref ( & self ) -> & Self :: Target { unsafe { & * TIMER0 :: ptr ( ) } } } # [ doc = "TIMER0" ]
pub mod timer0 { # [ doc = r"Register block" ]
# [ repr ( C ) ]
pub struct RegisterBlock { # [ doc = "0x00 - Load value when Timer is (re-)enabled. In One-Shot mode, the value written to this register specifies the Timer's duration in clock cycles." ]
pub load : LOAD , # [ doc = "0x04 - Reload value when Timer reaches ``0``. In Periodic mode, the value written to this register specify the Timer's period in clock cycles." ]
pub reload : RELOAD , # [ doc = "0x08 - Enable flag of the Timer. Set this flag to ``1`` to enable/start the Timer. Set to ``0`` to disable the Timer." ]
pub en : EN , # [ doc = "0x0c - Update trigger for the current countdown value. A write to this register latches the current countdown value to ``value`` register." ]
pub update_value : UPDATE_VALUE , # [ doc = "0x10 - Latched countdown value. This value is updated by writing to ``update_value``." ]
pub value : VALUE , # [ doc = "0x14 - " ]
pub ev_status : EV_STATUS , # [ doc = "0x18 - " ]
pub ev_pending : EV_PENDING , # [ doc = "0x1c - " ]
pub ev_enable : EV_ENABLE , } # [ doc = "Load value when Timer is (re-)enabled. In One-Shot mode, the value written to this register specifies the Timer's duration in clock cycles.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [load](load) module" ]
pub type LOAD = crate :: Reg < u32 , _LOAD > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _LOAD ; # [ doc = "`read()` method returns [load::R](load::R) reader structure" ]
impl crate :: Readable for LOAD { } # [ doc = "`write(|w| ..)` method takes [load::W](load::W) writer structure" ]
impl crate :: Writable for LOAD { } # [ doc = "Load value when Timer is (re-)enabled. In One-Shot mode, the value written to this register specifies the Timer's duration in clock cycles." ]
pub mod load { # [ doc = "Reader of register LOAD" ]
pub type R = crate :: R < u32 , super :: LOAD > ; # [ doc = "Writer for register LOAD" ]
pub type W = crate :: W < u32 , super :: LOAD > ; # [ doc = "Register LOAD `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: LOAD { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `load`" ]
pub type LOAD_R = crate :: R < u32 , u32 > ; # [ doc = "Write proxy for field `load`" ]
pub struct LOAD_W < 'a > { w : & 'a mut W , } impl < 'a > LOAD_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xffff_ffff ) | ( ( value as u32 ) & 0xffff_ffff ) ; self . w } } impl R { # [ doc = "Bits 0:31" ]
# [ inline ( always ) ]
pub fn load ( & self ) -> LOAD_R { LOAD_R :: new ( ( self . bits & 0xffff_ffff ) as u32 ) } } impl W { # [ doc = "Bits 0:31" ]
# [ inline ( always ) ]
pub fn load ( & mut self ) -> LOAD_W { LOAD_W { w : self } } } } # [ doc = "Reload value when Timer reaches ``0``. In Periodic mode, the value written to this register specify the Timer's period in clock cycles.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [reload](reload) module" ]
pub type RELOAD = crate :: Reg < u32 , _RELOAD > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _RELOAD ; # [ doc = "`read()` method returns [reload::R](reload::R) reader structure" ]
impl crate :: Readable for RELOAD { } # [ doc = "`write(|w| ..)` method takes [reload::W](reload::W) writer structure" ]
impl crate :: Writable for RELOAD { } # [ doc = "Reload value when Timer reaches ``0``. In Periodic mode, the value written to this register specify the Timer's period in clock cycles." ]
pub mod reload { # [ doc = "Reader of register RELOAD" ]
pub type R = crate :: R < u32 , super :: RELOAD > ; # [ doc = "Writer for register RELOAD" ]
pub type W = crate :: W < u32 , super :: RELOAD > ; # [ doc = "Register RELOAD `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: RELOAD { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `reload`" ]
pub type RELOAD_R = crate :: R < u32 , u32 > ; # [ doc = "Write proxy for field `reload`" ]
pub struct RELOAD_W < 'a > { w : & 'a mut W , } impl < 'a > RELOAD_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xffff_ffff ) | ( ( value as u32 ) & 0xffff_ffff ) ; self . w } } impl R { # [ doc = "Bits 0:31" ]
# [ inline ( always ) ]
pub fn reload ( & self ) -> RELOAD_R { RELOAD_R :: new ( ( self . bits & 0xffff_ffff ) as u32 ) } } impl W { # [ doc = "Bits 0:31" ]
# [ inline ( always ) ]
pub fn reload ( & mut self ) -> RELOAD_W { RELOAD_W { w : self } } } } # [ doc = "Enable flag of the Timer. Set this flag to ``1`` to enable/start the Timer. Set to ``0`` to disable the Timer.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [en](en) module" ]
pub type EN = crate :: Reg < u32 , _EN > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _EN ; # [ doc = "`read()` method returns [en::R](en::R) reader structure" ]
impl crate :: Readable for EN { } # [ doc = "`write(|w| ..)` method takes [en::W](en::W) writer structure" ]
impl crate :: Writable for EN { } # [ doc = "Enable flag of the Timer. Set this flag to ``1`` to enable/start the Timer. Set to ``0`` to disable the Timer." ]
pub mod en { # [ doc = "Reader of register EN" ]
pub type R = crate :: R < u32 , super :: EN > ; # [ doc = "Writer for register EN" ]
pub type W = crate :: W < u32 , super :: EN > ; # [ doc = "Register EN `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: EN { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `en`" ]
pub type EN_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `en`" ]
pub struct EN_W < 'a > { w : & 'a mut W , } impl < 'a > EN_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } } impl R { # [ doc = "Bit 0" ]
# [ inline ( always ) ]
pub fn en ( & self ) -> EN_R { EN_R :: new ( ( self . bits & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0" ]
# [ inline ( always ) ]
pub fn en ( & mut self ) -> EN_W { EN_W { w : self } } } } # [ doc = "Update trigger for the current countdown value. A write to this register latches the current countdown value to ``value`` register.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [update_value](update_value) module" ]
pub type UPDATE_VALUE = crate :: Reg < u32 , _UPDATE_VALUE > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _UPDATE_VALUE ; # [ doc = "`read()` method returns [update_value::R](update_value::R) reader structure" ]
impl crate :: Readable for UPDATE_VALUE { } # [ doc = "`write(|w| ..)` method takes [update_value::W](update_value::W) writer structure" ]
impl crate :: Writable for UPDATE_VALUE { } # [ doc = "Update trigger for the current countdown value. A write to this register latches the current countdown value to ``value`` register." ]
pub mod update_value { # [ doc = "Reader of register UPDATE_VALUE" ]
pub type R = crate :: R < u32 , super :: UPDATE_VALUE > ; # [ doc = "Writer for register UPDATE_VALUE" ]
pub type W = crate :: W < u32 , super :: UPDATE_VALUE > ; # [ doc = "Register UPDATE_VALUE `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: UPDATE_VALUE { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `update_value`" ]
pub type UPDATE_VALUE_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `update_value`" ]
pub struct UPDATE_VALUE_W < 'a > { w : & 'a mut W , } impl < 'a > UPDATE_VALUE_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } } impl R { # [ doc = "Bit 0" ]
# [ inline ( always ) ]
pub fn update_value ( & self ) -> UPDATE_VALUE_R { UPDATE_VALUE_R :: new ( ( self . bits & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0" ]
# [ inline ( always ) ]
pub fn update_value ( & mut self ) -> UPDATE_VALUE_W { UPDATE_VALUE_W { w : self } } } } # [ doc = "Latched countdown value. This value is updated by writing to ``update_value``.\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [value](value) module" ]
pub type VALUE = crate :: Reg < u32 , _VALUE > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _VALUE ; # [ doc = "`read()` method returns [value::R](value::R) reader structure" ]
impl crate :: Readable for VALUE { } # [ doc = "Latched countdown value. This value is updated by writing to ``update_value``." ]
pub mod value { # [ doc = "Reader of register VALUE" ]
pub type R = crate :: R < u32 , super :: VALUE > ; # [ doc = "Reader of field `value`" ]
pub type VALUE_R = crate :: R < u32 , u32 > ; impl R { # [ doc = "Bits 0:31" ]
# [ inline ( always ) ]
pub fn value ( & self ) -> VALUE_R { VALUE_R :: new ( ( self . bits & 0xffff_ffff ) as u32 ) } } } # [ doc = "\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ev_status](ev_status) module" ]
pub type EV_STATUS = crate :: Reg < u32 , _EV_STATUS > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _EV_STATUS ; # [ doc = "`read()` method returns [ev_status::R](ev_status::R) reader structure" ]
impl crate :: Readable for EV_STATUS { } # [ doc = "`write(|w| ..)` method takes [ev_status::W](ev_status::W) writer structure" ]
impl crate :: Writable for EV_STATUS { } # [ doc = "" ]
pub mod ev_status { # [ doc = "Reader of register EV_STATUS" ]
pub type R = crate :: R < u32 , super :: EV_STATUS > ; # [ doc = "Writer for register EV_STATUS" ]
pub type W = crate :: W < u32 , super :: EV_STATUS > ; # [ doc = "Register EV_STATUS `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: EV_STATUS { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `status`" ]
pub type STATUS_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `status`" ]
pub struct STATUS_W < 'a > { w : & 'a mut W , } impl < 'a > STATUS_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } } impl R { # [ doc = "Bit 0" ]
# [ inline ( always ) ]
pub fn status ( & self ) -> STATUS_R { STATUS_R :: new ( ( self . bits & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0" ]
# [ inline ( always ) ]
pub fn status ( & mut self ) -> STATUS_W { STATUS_W { w : self } } } } # [ doc = "\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ev_pending](ev_pending) module" ]
pub type EV_PENDING = crate :: Reg < u32 , _EV_PENDING > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _EV_PENDING ; # [ doc = "`read()` method returns [ev_pending::R](ev_pending::R) reader structure" ]
impl crate :: Readable for EV_PENDING { } # [ doc = "`write(|w| ..)` method takes [ev_pending::W](ev_pending::W) writer structure" ]
impl crate :: Writable for EV_PENDING { } # [ doc = "" ]
pub mod ev_pending { # [ doc = "Reader of register EV_PENDING" ]
pub type R = crate :: R < u32 , super :: EV_PENDING > ; # [ doc = "Writer for register EV_PENDING" ]
pub type W = crate :: W < u32 , super :: EV_PENDING > ; # [ doc = "Register EV_PENDING `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: EV_PENDING { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `pending`" ]
pub type PENDING_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `pending`" ]
pub struct PENDING_W < 'a > { w : & 'a mut W , } impl < 'a > PENDING_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } } impl R { # [ doc = "Bit 0" ]
# [ inline ( always ) ]
pub fn pending ( & self ) -> PENDING_R { PENDING_R :: new ( ( self . bits & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0" ]
# [ inline ( always ) ]
pub fn pending ( & mut self ) -> PENDING_W { PENDING_W { w : self } } } } # [ doc = "\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ev_enable](ev_enable) module" ]
pub type EV_ENABLE = crate :: Reg < u32 , _EV_ENABLE > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _EV_ENABLE ; # [ doc = "`read()` method returns [ev_enable::R](ev_enable::R) reader structure" ]
impl crate :: Readable for EV_ENABLE { } # [ doc = "`write(|w| ..)` method takes [ev_enable::W](ev_enable::W) writer structure" ]
impl crate :: Writable for EV_ENABLE { } # [ doc = "" ]
pub mod ev_enable { # [ doc = "Reader of register EV_ENABLE" ]
pub type R = crate :: R < u32 , super :: EV_ENABLE > ; # [ doc = "Writer for register EV_ENABLE" ]
pub type W = crate :: W < u32 , super :: EV_ENABLE > ; # [ doc = "Register EV_ENABLE `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: EV_ENABLE { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `enable`" ]
pub type ENABLE_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `enable`" ]
pub struct ENABLE_W < 'a > { w : & 'a mut W , } impl < 'a > ENABLE_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } } impl R { # [ doc = "Bit 0" ]
# [ inline ( always ) ]
pub fn enable ( & self ) -> ENABLE_R { ENABLE_R :: new ( ( self . bits & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0" ]
# [ inline ( always ) ]
pub fn enable ( & mut self ) -> ENABLE_W { ENABLE_W { w : self } } } } } # [ doc = "IDENTIFIER_MEM" ]
pub struct IDENTIFIER_MEM { _marker : PhantomData < * const ( ) > } unsafe impl Send for IDENTIFIER_MEM { } impl IDENTIFIER_MEM { # [ doc = r"Returns a pointer to the register block" ]
# [ inline ( always ) ]
pub const fn ptr ( ) -> * const identifier_mem :: RegisterBlock { 0x8200_2000 as * const _ } } impl Deref for IDENTIFIER_MEM { type Target = identifier_mem :: RegisterBlock ; # [ inline ( always ) ]
fn deref ( & self ) -> & Self :: Target { unsafe { & * IDENTIFIER_MEM :: ptr ( ) } } } # [ doc = "IDENTIFIER_MEM" ]
pub mod identifier_mem { # [ doc = r"Register block" ]
# [ repr ( C ) ]
pub struct RegisterBlock { # [ doc = "0x00 - 8 x 26-bit memory" ]
pub identifier_mem : IDENTIFIER_MEM , } # [ doc = "8 x 26-bit memory\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [identifier_mem](identifier_mem) module" ]
pub type IDENTIFIER_MEM = crate :: Reg < u32 , _IDENTIFIER_MEM > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _IDENTIFIER_MEM ; # [ doc = "`read()` method returns [identifier_mem::R](identifier_mem::R) reader structure" ]
impl crate :: Readable for IDENTIFIER_MEM { } # [ doc = "`write(|w| ..)` method takes [identifier_mem::W](identifier_mem::W) writer structure" ]
impl crate :: Writable for IDENTIFIER_MEM { } # [ doc = "8 x 26-bit memory" ]
pub mod identifier_mem { # [ doc = "Reader of register IDENTIFIER_MEM" ]
pub type R = crate :: R < u32 , super :: IDENTIFIER_MEM > ; # [ doc = "Writer for register IDENTIFIER_MEM" ]
pub type W = crate :: W < u32 , super :: IDENTIFIER_MEM > ; # [ doc = "Register IDENTIFIER_MEM `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: IDENTIFIER_MEM { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `identifier_mem`" ]
pub type IDENTIFIER_MEM_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `identifier_mem`" ]
pub struct IDENTIFIER_MEM_W < 'a > { w : & 'a mut W , } impl < 'a > IDENTIFIER_MEM_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xff ) | ( ( value as u32 ) & 0xff ) ; self . w } } impl R { # [ doc = "Bits 0:7" ]
# [ inline ( always ) ]
pub fn identifier_mem ( & self ) -> IDENTIFIER_MEM_R { IDENTIFIER_MEM_R :: new ( ( self . bits & 0xff ) as u8 ) } } impl W { # [ doc = "Bits 0:7" ]
# [ inline ( always ) ]
pub fn identifier_mem ( & mut self ) -> IDENTIFIER_MEM_W { IDENTIFIER_MEM_W { w : self } } } } } # [ doc = "MEMLCD" ]
pub struct MEMLCD { _marker : PhantomData < * const ( ) > } unsafe impl Send for MEMLCD { } impl MEMLCD { # [ doc = r"Returns a pointer to the register block" ]
# [ inline ( always ) ]
pub const fn ptr ( ) -> * const memlcd :: RegisterBlock { 0x8200_7000 as * const _ } } impl Deref for MEMLCD { type Target = memlcd :: RegisterBlock ; # [ inline ( always ) ]
fn deref ( & self ) -> & Self :: Target { unsafe { & * MEMLCD :: ptr ( ) } } } # [ doc = "MEMLCD" ]
pub mod memlcd { # [ doc = r"Register block" ]
# [ repr ( C ) ]
pub struct RegisterBlock { # [ doc = "0x00 - " ]
pub command : COMMAND , # [ doc = "0x04 - A ``1`` indicates that the block is currently updating the LCD" ]
pub busy : BUSY , # [ doc = "0x08 - Prescaler value. LCD clock is module (clock / (prescaler+1)). Reset value: 99, so for a default sysclk of 100MHz this yields an LCD SCLK of 1MHz" ]
pub prescaler : PRESCALER , # [ doc = "0x0c - " ]
pub ev_status : EV_STATUS , # [ doc = "0x10 - " ]
pub ev_pending : EV_PENDING , # [ doc = "0x14 - " ]
pub ev_enable : EV_ENABLE , } # [ doc = "\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [command](command) module" ]
pub type COMMAND = crate :: Reg < u32 , _COMMAND > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _COMMAND ; # [ doc = "`read()` method returns [command::R](command::R) reader structure" ]
impl crate :: Readable for COMMAND { } # [ doc = "`write(|w| ..)` method takes [command::W](command::W) writer structure" ]
impl crate :: Writable for COMMAND { } # [ doc = "" ]
pub mod command { # [ doc = "Reader of register COMMAND" ]
pub type R = crate :: R < u32 , super :: COMMAND > ; # [ doc = "Writer for register COMMAND" ]
pub type W = crate :: W < u32 , super :: COMMAND > ; # [ doc = "Register COMMAND `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: COMMAND { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `UpdateDirty`" ]
pub type UPDATEDIRTY_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `UpdateDirty`" ]
pub struct UPDATEDIRTY_W < 'a > { w : & 'a mut W , } impl < 'a > UPDATEDIRTY_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `UpdateAll`" ]
pub type UPDATEALL_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `UpdateAll`" ]
pub struct UPDATEALL_W < 'a > { w : & 'a mut W , } impl < 'a > UPDATEALL_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } } impl R { # [ doc = "Bit 0 - Write a ``1`` to flush dirty lines to the LCD" ]
# [ inline ( always ) ]
pub fn update_dirty ( & self ) -> UPDATEDIRTY_R { UPDATEDIRTY_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - Update full screen regardless of tag state" ]
# [ inline ( always ) ]
pub fn update_all ( & self ) -> UPDATEALL_R { UPDATEALL_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - Write a ``1`` to flush dirty lines to the LCD" ]
# [ inline ( always ) ]
pub fn update_dirty ( & mut self ) -> UPDATEDIRTY_W { UPDATEDIRTY_W { w : self } } # [ doc = "Bit 1 - Update full screen regardless of tag state" ]
# [ inline ( always ) ]
pub fn update_all ( & mut self ) -> UPDATEALL_W { UPDATEALL_W { w : self } } } } # [ doc = "A ``1`` indicates that the block is currently updating the LCD\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [busy](busy) module" ]
pub type BUSY = crate :: Reg < u32 , _BUSY > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _BUSY ; # [ doc = "`read()` method returns [busy::R](busy::R) reader structure" ]
impl crate :: Readable for BUSY { } # [ doc = "A ``1`` indicates that the block is currently updating the LCD" ]
pub mod busy { # [ doc = "Reader of register BUSY" ]
pub type R = crate :: R < u32 , super :: BUSY > ; # [ doc = "Reader of field `busy`" ]
pub type BUSY_R = crate :: R < bool , bool > ; impl R { # [ doc = "Bit 0" ]
# [ inline ( always ) ]
pub fn busy ( & self ) -> BUSY_R { BUSY_R :: new ( ( self . bits & 0x01 ) != 0 ) } } } # [ doc = "Prescaler value. LCD clock is module (clock / (prescaler+1)). Reset value: 99, so for a default sysclk of 100MHz this yields an LCD SCLK of 1MHz\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [prescaler](prescaler) module" ]
pub type PRESCALER = crate :: Reg < u32 , _PRESCALER > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _PRESCALER ; # [ doc = "`read()` method returns [prescaler::R](prescaler::R) reader structure" ]
impl crate :: Readable for PRESCALER { } # [ doc = "`write(|w| ..)` method takes [prescaler::W](prescaler::W) writer structure" ]
impl crate :: Writable for PRESCALER { } # [ doc = "Prescaler value. LCD clock is module (clock / (prescaler+1)). Reset value: 99, so for a default sysclk of 100MHz this yields an LCD SCLK of 1MHz" ]
pub mod prescaler { # [ doc = "Reader of register PRESCALER" ]
pub type R = crate :: R < u32 , super :: PRESCALER > ; # [ doc = "Writer for register PRESCALER" ]
pub type W = crate :: W < u32 , super :: PRESCALER > ; # [ doc = "Register PRESCALER `reset()`'s with value 0x63" ]
impl crate :: ResetValue for super :: PRESCALER { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0x63 } } # [ doc = "Reader of field `prescaler`" ]
pub type PRESCALER_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `prescaler`" ]
pub struct PRESCALER_W < 'a > { w : & 'a mut W , } impl < 'a > PRESCALER_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xff ) | ( ( value as u32 ) & 0xff ) ; self . w } } impl R { # [ doc = "Bits 0:7" ]
# [ inline ( always ) ]
pub fn prescaler ( & self ) -> PRESCALER_R { PRESCALER_R :: new ( ( self . bits & 0xff ) as u8 ) } } impl W { # [ doc = "Bits 0:7" ]
# [ inline ( always ) ]
pub fn prescaler ( & mut self ) -> PRESCALER_W { PRESCALER_W { w : self } } } } # [ doc = "\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ev_status](ev_status) module" ]
pub type EV_STATUS = crate :: Reg < u32 , _EV_STATUS > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _EV_STATUS ; # [ doc = "`read()` method returns [ev_status::R](ev_status::R) reader structure" ]
impl crate :: Readable for EV_STATUS { } # [ doc = "`write(|w| ..)` method takes [ev_status::W](ev_status::W) writer structure" ]
impl crate :: Writable for EV_STATUS { } # [ doc = "" ]
pub mod ev_status { # [ doc = "Reader of register EV_STATUS" ]
pub type R = crate :: R < u32 , super :: EV_STATUS > ; # [ doc = "Writer for register EV_STATUS" ]
pub type W = crate :: W < u32 , super :: EV_STATUS > ; # [ doc = "Register EV_STATUS `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: EV_STATUS { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `status`" ]
pub type STATUS_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `status`" ]
pub struct STATUS_W < 'a > { w : & 'a mut W , } impl < 'a > STATUS_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } } impl R { # [ doc = "Bit 0" ]
# [ inline ( always ) ]
pub fn status ( & self ) -> STATUS_R { STATUS_R :: new ( ( self . bits & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0" ]
# [ inline ( always ) ]
pub fn status ( & mut self ) -> STATUS_W { STATUS_W { w : self } } } } # [ doc = "\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ev_pending](ev_pending) module" ]
pub type EV_PENDING = crate :: Reg < u32 , _EV_PENDING > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _EV_PENDING ; # [ doc = "`read()` method returns [ev_pending::R](ev_pending::R) reader structure" ]
impl crate :: Readable for EV_PENDING { } # [ doc = "`write(|w| ..)` method takes [ev_pending::W](ev_pending::W) writer structure" ]
impl crate :: Writable for EV_PENDING { } # [ doc = "" ]
pub mod ev_pending { # [ doc = "Reader of register EV_PENDING" ]
pub type R = crate :: R < u32 , super :: EV_PENDING > ; # [ doc = "Writer for register EV_PENDING" ]
pub type W = crate :: W < u32 , super :: EV_PENDING > ; # [ doc = "Register EV_PENDING `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: EV_PENDING { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `pending`" ]
pub type PENDING_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `pending`" ]
pub struct PENDING_W < 'a > { w : & 'a mut W , } impl < 'a > PENDING_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } } impl R { # [ doc = "Bit 0" ]
# [ inline ( always ) ]
pub fn pending ( & self ) -> PENDING_R { PENDING_R :: new ( ( self . bits & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0" ]
# [ inline ( always ) ]
pub fn pending ( & mut self ) -> PENDING_W { PENDING_W { w : self } } } } # [ doc = "\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ev_enable](ev_enable) module" ]
pub type EV_ENABLE = crate :: Reg < u32 , _EV_ENABLE > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _EV_ENABLE ; # [ doc = "`read()` method returns [ev_enable::R](ev_enable::R) reader structure" ]
impl crate :: Readable for EV_ENABLE { } # [ doc = "`write(|w| ..)` method takes [ev_enable::W](ev_enable::W) writer structure" ]
impl crate :: Writable for EV_ENABLE { } # [ doc = "" ]
pub mod ev_enable { # [ doc = "Reader of register EV_ENABLE" ]
pub type R = crate :: R < u32 , super :: EV_ENABLE > ; # [ doc = "Writer for register EV_ENABLE" ]
pub type W = crate :: W < u32 , super :: EV_ENABLE > ; # [ doc = "Register EV_ENABLE `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: EV_ENABLE { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `enable`" ]
pub type ENABLE_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `enable`" ]
pub struct ENABLE_W < 'a > { w : & 'a mut W , } impl < 'a > ENABLE_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } } impl R { # [ doc = "Bit 0" ]
# [ inline ( always ) ]
pub fn enable ( & self ) -> ENABLE_R { ENABLE_R :: new ( ( self . bits & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0" ]
# [ inline ( always ) ]
pub fn enable ( & mut self ) -> ENABLE_W { ENABLE_W { w : self } } } } } # [ doc = "CTRL" ]
pub struct CTRL { _marker : PhantomData < * const ( ) > } unsafe impl Send for CTRL { } impl CTRL { # [ doc = r"Returns a pointer to the register block" ]
# [ inline ( always ) ]
pub const fn ptr ( ) -> * const ctrl :: RegisterBlock { 0x8200_0000 as * const _ } } impl Deref for CTRL { type Target = ctrl :: RegisterBlock ; # [ inline ( always ) ]
fn deref ( & self ) -> & Self :: Target { unsafe { & * CTRL :: ptr ( ) } } } # [ doc = "CTRL" ]
pub mod ctrl { # [ doc = r"Register block" ]
# [ repr ( C ) ]
pub struct RegisterBlock { # [ doc = "0x00 - Write a ``1`` to this register to reset the SoC." ]
pub reset : RESET , # [ doc = "0x04 - Use this register as a scratch space to verify that software read/write accesses to the Wishbone/CSR bus are working correctly. The initial reset value of 0x1234578 can be used to verify endianness." ]
pub scratch : SCRATCH , # [ doc = "0x08 - Total number of Wishbone bus errors (timeouts) since last reset." ]
pub bus_errors : BUS_ERRORS , } # [ doc = "Write a ``1`` to this register to reset the SoC.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [reset](reset) module" ]
pub type RESET = crate :: Reg < u32 , _RESET > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _RESET ; # [ doc = "`read()` method returns [reset::R](reset::R) reader structure" ]
impl crate :: Readable for RESET { } # [ doc = "`write(|w| ..)` method takes [reset::W](reset::W) writer structure" ]
impl crate :: Writable for RESET { } # [ doc = "Write a ``1`` to this register to reset the SoC." ]
pub mod reset { # [ doc = "Reader of register RESET" ]
pub type R = crate :: R < u32 , super :: RESET > ; # [ doc = "Writer for register RESET" ]
pub type W = crate :: W < u32 , super :: RESET > ; # [ doc = "Register RESET `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: RESET { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `reset`" ]
pub type RESET_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `reset`" ]
pub struct RESET_W < 'a > { w : & 'a mut W , } impl < 'a > RESET_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } } impl R { # [ doc = "Bit 0" ]
# [ inline ( always ) ]
pub fn reset ( & self ) -> RESET_R { RESET_R :: new ( ( self . bits & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0" ]
# [ inline ( always ) ]
pub fn reset ( & mut self ) -> RESET_W { RESET_W { w : self } } } } # [ doc = "Use this register as a scratch space to verify that software read/write accesses to the Wishbone/CSR bus are working correctly. The initial reset value of 0x1234578 can be used to verify endianness.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [scratch](scratch) module" ]
pub type SCRATCH = crate :: Reg < u32 , _SCRATCH > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _SCRATCH ; # [ doc = "`read()` method returns [scratch::R](scratch::R) reader structure" ]
impl crate :: Readable for SCRATCH { } # [ doc = "`write(|w| ..)` method takes [scratch::W](scratch::W) writer structure" ]
impl crate :: Writable for SCRATCH { } # [ doc = "Use this register as a scratch space to verify that software read/write accesses to the Wishbone/CSR bus are working correctly. The initial reset value of 0x1234578 can be used to verify endianness." ]
pub mod scratch { # [ doc = "Reader of register SCRATCH" ]
pub type R = crate :: R < u32 , super :: SCRATCH > ; # [ doc = "Writer for register SCRATCH" ]
pub type W = crate :: W < u32 , super :: SCRATCH > ; # [ doc = "Register SCRATCH `reset()`'s with value 0x1234_5678" ]
impl crate :: ResetValue for super :: SCRATCH { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0x1234_5678 } } # [ doc = "Reader of field `scratch`" ]
pub type SCRATCH_R = crate :: R < u32 , u32 > ; # [ doc = "Write proxy for field `scratch`" ]
pub struct SCRATCH_W < 'a > { w : & 'a mut W , } impl < 'a > SCRATCH_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xffff_ffff ) | ( ( value as u32 ) & 0xffff_ffff ) ; self . w } } impl R { # [ doc = "Bits 0:31" ]
# [ inline ( always ) ]
pub fn scratch ( & self ) -> SCRATCH_R { SCRATCH_R :: new ( ( self . bits & 0xffff_ffff ) as u32 ) } } impl W { # [ doc = "Bits 0:31" ]
# [ inline ( always ) ]
pub fn scratch ( & mut self ) -> SCRATCH_W { SCRATCH_W { w : self } } } } # [ doc = "Total number of Wishbone bus errors (timeouts) since last reset.\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [bus_errors](bus_errors) module" ]
pub type BUS_ERRORS = crate :: Reg < u32 , _BUS_ERRORS > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _BUS_ERRORS ; # [ doc = "`read()` method returns [bus_errors::R](bus_errors::R) reader structure" ]
impl crate :: Readable for BUS_ERRORS { } # [ doc = "Total number of Wishbone bus errors (timeouts) since last reset." ]
pub mod bus_errors { # [ doc = "Reader of register BUS_ERRORS" ]
pub type R = crate :: R < u32 , super :: BUS_ERRORS > ; # [ doc = "Reader of field `bus_errors`" ]
pub type BUS_ERRORS_R = crate :: R < u32 , u32 > ; impl R { # [ doc = "Bits 0:31" ]
# [ inline ( always ) ]
pub fn bus_errors ( & self ) -> BUS_ERRORS_R { BUS_ERRORS_R :: new ( ( self . bits & 0xffff_ffff ) as u32 ) } } } } # [ doc = "SIMSTATUS" ]
pub struct SIMSTATUS { _marker : PhantomData < * const ( ) > } unsafe impl Send for SIMSTATUS { } impl SIMSTATUS { # [ doc = r"Returns a pointer to the register block" ]
# [ inline ( always ) ]
pub const fn ptr ( ) -> * const simstatus :: RegisterBlock { 0x8200_6000 as * const _ } } impl Deref for SIMSTATUS { type Target = simstatus :: RegisterBlock ; # [ inline ( always ) ]
fn deref ( & self ) -> & Self :: Target { unsafe { & * SIMSTATUS :: ptr ( ) } } } # [ doc = "SIMSTATUS" ]
pub mod simstatus { # [ doc = r"Register block" ]
# [ repr ( C ) ]
pub struct RegisterBlock { # [ doc = "0x00 - status output for simulator" ]
pub simstatus : SIMSTATUS , } # [ doc = "status output for simulator\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [simstatus](simstatus) module" ]
pub type SIMSTATUS = crate :: Reg < u32 , _SIMSTATUS > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _SIMSTATUS ; # [ doc = "`read()` method returns [simstatus::R](simstatus::R) reader structure" ]
impl crate :: Readable for SIMSTATUS { } # [ doc = "`write(|w| ..)` method takes [simstatus::W](simstatus::W) writer structure" ]
impl crate :: Writable for SIMSTATUS { } # [ doc = "status output for simulator" ]
pub mod simstatus { # [ doc = "Reader of register SIMSTATUS" ]
pub type R = crate :: R < u32 , super :: SIMSTATUS > ; # [ doc = "Writer for register SIMSTATUS" ]
pub type W = crate :: W < u32 , super :: SIMSTATUS > ; # [ doc = "Register SIMSTATUS `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: SIMSTATUS { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `success`" ]
pub type SUCCESS_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `success`" ]
pub struct SUCCESS_W < 'a > { w : & 'a mut W , } impl < 'a > SUCCESS_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `report`" ]
pub type REPORT_R = crate :: R < u16 , u16 > ; # [ doc = "Write proxy for field `report`" ]
pub struct REPORT_W < 'a > { w : & 'a mut W , } impl < 'a > REPORT_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0xffff << 1 ) ) | ( ( ( value as u32 ) & 0xffff ) << 1 ) ; self . w } } impl R { # [ doc = "Bit 0 - Write `1` if simulation was a success" ]
# [ inline ( always ) ]
pub fn success ( & self ) -> SUCCESS_R { SUCCESS_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bits 1:16 - A 16-bit field to report a result" ]
# [ inline ( always ) ]
pub fn report ( & self ) -> REPORT_R { REPORT_R :: new ( ( ( self . bits >> 1 ) & 0xffff ) as u16 ) } } impl W { # [ doc = "Bit 0 - Write `1` if simulation was a success" ]
# [ inline ( always ) ]
pub fn success ( & mut self ) -> SUCCESS_W { SUCCESS_W { w : self } } # [ doc = "Bits 1:16 - A 16-bit field to report a result" ]
# [ inline ( always ) ]
pub fn report ( & mut self ) -> REPORT_W { REPORT_W { w : self } } } } } # [ doc = "SRAM_EXT" ]
pub struct SRAM_EXT { _marker : PhantomData < * const ( ) > } unsafe impl Send for SRAM_EXT { } impl SRAM_EXT { # [ doc = r"Returns a pointer to the register block" ]
# [ inline ( always ) ]
pub const fn ptr ( ) -> * const sram_ext :: RegisterBlock { 0x8200_8000 as * const _ } } impl Deref for SRAM_EXT { type Target = sram_ext :: RegisterBlock ; # [ inline ( always ) ]
fn deref ( & self ) -> & Self :: Target { unsafe { & * SRAM_EXT :: ptr ( ) } } } # [ doc = "SRAM_EXT" ]
pub mod sram_ext { # [ doc = r"Register block" ]
# [ repr ( C ) ]
pub struct RegisterBlock { # [ doc = "0x00 - " ]
pub config_status : CONFIG_STATUS , # [ doc = "0x04 - " ]
pub read_config : READ_CONFIG , } # [ doc = "\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [config_status](config_status) module" ]
pub type CONFIG_STATUS = crate :: Reg < u32 , _CONFIG_STATUS > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _CONFIG_STATUS ; # [ doc = "`read()` method returns [config_status::R](config_status::R) reader structure" ]
impl crate :: Readable for CONFIG_STATUS { } # [ doc = "" ]
pub mod config_status { # [ doc = "Reader of register CONFIG_STATUS" ]
pub type R = crate :: R < u32 , super :: CONFIG_STATUS > ; # [ doc = "Reader of field `mode`" ]
pub type MODE_R = crate :: R < u32 , u32 > ; impl R { # [ doc = "Bits 0:31 - The current configuration mode of the SRAM" ]
# [ inline ( always ) ]
pub fn mode ( & self ) -> MODE_R { MODE_R :: new ( ( self . bits & 0xffff_ffff ) as u32 ) } } } # [ doc = "\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [read_config](read_config) module" ]
pub type READ_CONFIG = crate :: Reg < u32 , _READ_CONFIG > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _READ_CONFIG ; # [ doc = "`read()` method returns [read_config::R](read_config::R) reader structure" ]
impl crate :: Readable for READ_CONFIG { } # [ doc = "`write(|w| ..)` method takes [read_config::W](read_config::W) writer structure" ]
impl crate :: Writable for READ_CONFIG { } # [ doc = "" ]
pub mod read_config { # [ doc = "Reader of register READ_CONFIG" ]
pub type R = crate :: R < u32 , super :: READ_CONFIG > ; # [ doc = "Writer for register READ_CONFIG" ]
pub type W = crate :: W < u32 , super :: READ_CONFIG > ; # [ doc = "Register READ_CONFIG `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: READ_CONFIG { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `trigger`" ]
pub type TRIGGER_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `trigger`" ]
pub struct TRIGGER_W < 'a > { w : & 'a mut W , } impl < 'a > TRIGGER_W < 'a > { # [ doc = r"Sets the field bit" ]
# [ inline ( always ) ]
pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ]
# [ inline ( always ) ]
pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } } impl R { # [ doc = "Bit 0 - Writing to this bit triggers the SRAM mode status read update" ]
# [ inline ( always ) ]
pub fn trigger ( & self ) -> TRIGGER_R { TRIGGER_R :: new ( ( self . bits & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - Writing to this bit triggers the SRAM mode status read update" ]
# [ inline ( always ) ]
pub fn trigger ( & mut self ) -> TRIGGER_W { TRIGGER_W { w : self } } } } } # [ doc = "UART" ]
pub struct UART { _marker : PhantomData < * const ( ) > } unsafe impl Send for UART { } impl UART { # [ doc = r"Returns a pointer to the register block" ]
# [ inline ( always ) ]
pub const fn ptr ( ) -> * const uart :: RegisterBlock { 0x8200_4000 as * const _ } } impl Deref for UART { type Target = uart :: RegisterBlock ; # [ inline ( always ) ]
fn deref ( & self ) -> & Self :: Target { unsafe { & * UART :: ptr ( ) } } } # [ doc = "UART" ]
pub mod uart { # [ doc = r"Register block" ]
# [ repr ( C ) ]
pub struct RegisterBlock { # [ doc = "0x00 - " ]
pub rxtx : RXTX , # [ doc = "0x04 - " ]
pub txfull : TXFULL , # [ doc = "0x08 - " ]
pub rxempty : RXEMPTY , # [ doc = "0x0c - " ]
pub ev_status : EV_STATUS , # [ doc = "0x10 - " ]
pub ev_pending : EV_PENDING , # [ doc = "0x14 - " ]
pub ev_enable : EV_ENABLE , # [ doc = "0x18 - " ]
pub xover_rxtx : XOVER_RXTX , # [ doc = "0x1c - " ]
pub xover_txfull : XOVER_TXFULL , # [ doc = "0x20 - " ]
pub xover_rxempty : XOVER_RXEMPTY , # [ doc = "0x24 - " ]
pub xover_ev_status : XOVER_EV_STATUS , # [ doc = "0x28 - " ]
pub xover_ev_pending : XOVER_EV_PENDING , # [ doc = "0x2c - " ]
pub xover_ev_enable : XOVER_EV_ENABLE , } # [ doc = "\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rxtx](rxtx) module" ]
pub type RXTX = crate :: Reg < u32 , _RXTX > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _RXTX ; # [ doc = "`read()` method returns [rxtx::R](rxtx::R) reader structure" ]
impl crate :: Readable for RXTX { } # [ doc = "`write(|w| ..)` method takes [rxtx::W](rxtx::W) writer structure" ]
impl crate :: Writable for RXTX { } # [ doc = "" ]
pub mod rxtx { # [ doc = "Reader of register RXTX" ]
pub type R = crate :: R < u32 , super :: RXTX > ; # [ doc = "Writer for register RXTX" ]
pub type W = crate :: W < u32 , super :: RXTX > ; # [ doc = "Register RXTX `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: RXTX { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `rxtx`" ]
pub type RXTX_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `rxtx`" ]
pub struct RXTX_W < 'a > { w : & 'a mut W , } impl < 'a > RXTX_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xff ) | ( ( value as u32 ) & 0xff ) ; self . w } } impl R { # [ doc = "Bits 0:7" ]
# [ inline ( always ) ]
pub fn rxtx ( & self ) -> RXTX_R { RXTX_R :: new ( ( self . bits & 0xff ) as u8 ) } } impl W { # [ doc = "Bits 0:7" ]
# [ inline ( always ) ]
pub fn rxtx ( & mut self ) -> RXTX_W { RXTX_W { w : self } } } } # [ doc = "\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [txfull](txfull) module" ]
pub type TXFULL = crate :: Reg < u32 , _TXFULL > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _TXFULL ; # [ doc = "`read()` method returns [txfull::R](txfull::R) reader structure" ]
impl crate :: Readable for TXFULL { } # [ doc = "" ]
pub mod txfull { # [ doc = "Reader of register TXFULL" ]
pub type R = crate :: R < u32 , super :: TXFULL > ; # [ doc = "Reader of field `txfull`" ]
pub type TXFULL_R = crate :: R < bool , bool > ; impl R { # [ doc = "Bit 0" ]
# [ inline ( always ) ]
pub fn txfull ( & self ) -> TXFULL_R { TXFULL_R :: new ( ( self . bits & 0x01 ) != 0 ) } } } # [ doc = "\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rxempty](rxempty) module" ]
pub type RXEMPTY = crate :: Reg < u32 , _RXEMPTY > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _RXEMPTY ; # [ doc = "`read()` method returns [rxempty::R](rxempty::R) reader structure" ]
impl crate :: Readable for RXEMPTY { } # [ doc = "" ]
pub mod rxempty { # [ doc = "Reader of register RXEMPTY" ]
pub type R = crate :: R < u32 , super :: RXEMPTY > ; # [ doc = "Reader of field `rxempty`" ]
pub type RXEMPTY_R = crate :: R < bool , bool > ; impl R { # [ doc = "Bit 0" ]
# [ inline ( always ) ]
pub fn rxempty ( & self ) -> RXEMPTY_R { RXEMPTY_R :: new ( ( self . bits & 0x01 ) != 0 ) } } } # [ doc = "\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ev_status](ev_status) module" ]
pub type EV_STATUS = crate :: Reg < u32 , _EV_STATUS > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _EV_STATUS ; # [ doc = "`read()` method returns [ev_status::R](ev_status::R) reader structure" ]
impl crate :: Readable for EV_STATUS { } # [ doc = "`write(|w| ..)` method takes [ev_status::W](ev_status::W) writer structure" ]
impl crate :: Writable for EV_STATUS { } # [ doc = "" ]
pub mod ev_status { # [ doc = "Reader of register EV_STATUS" ]
pub type R = crate :: R < u32 , super :: EV_STATUS > ; # [ doc = "Writer for register EV_STATUS" ]
pub type W = crate :: W < u32 , super :: EV_STATUS > ; # [ doc = "Register EV_STATUS `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: EV_STATUS { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `status`" ]
pub type STATUS_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `status`" ]
pub struct STATUS_W < 'a > { w : & 'a mut W , } impl < 'a > STATUS_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x03 ) | ( ( value as u32 ) & 0x03 ) ; self . w } } impl R { # [ doc = "Bits 0:1" ]
# [ inline ( always ) ]
pub fn status ( & self ) -> STATUS_R { STATUS_R :: new ( ( self . bits & 0x03 ) as u8 ) } } impl W { # [ doc = "Bits 0:1" ]
# [ inline ( always ) ]
pub fn status ( & mut self ) -> STATUS_W { STATUS_W { w : self } } } } # [ doc = "\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ev_pending](ev_pending) module" ]
pub type EV_PENDING = crate :: Reg < u32 , _EV_PENDING > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _EV_PENDING ; # [ doc = "`read()` method returns [ev_pending::R](ev_pending::R) reader structure" ]
impl crate :: Readable for EV_PENDING { } # [ doc = "`write(|w| ..)` method takes [ev_pending::W](ev_pending::W) writer structure" ]
impl crate :: Writable for EV_PENDING { } # [ doc = "" ]
pub mod ev_pending { # [ doc = "Reader of register EV_PENDING" ]
pub type R = crate :: R < u32 , super :: EV_PENDING > ; # [ doc = "Writer for register EV_PENDING" ]
pub type W = crate :: W < u32 , super :: EV_PENDING > ; # [ doc = "Register EV_PENDING `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: EV_PENDING { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `pending`" ]
pub type PENDING_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `pending`" ]
pub struct PENDING_W < 'a > { w : & 'a mut W , } impl < 'a > PENDING_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x03 ) | ( ( value as u32 ) & 0x03 ) ; self . w } } impl R { # [ doc = "Bits 0:1" ]
# [ inline ( always ) ]
pub fn pending ( & self ) -> PENDING_R { PENDING_R :: new ( ( self . bits & 0x03 ) as u8 ) } } impl W { # [ doc = "Bits 0:1" ]
# [ inline ( always ) ]
pub fn pending ( & mut self ) -> PENDING_W { PENDING_W { w : self } } } } # [ doc = "\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ev_enable](ev_enable) module" ]
pub type EV_ENABLE = crate :: Reg < u32 , _EV_ENABLE > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _EV_ENABLE ; # [ doc = "`read()` method returns [ev_enable::R](ev_enable::R) reader structure" ]
impl crate :: Readable for EV_ENABLE { } # [ doc = "`write(|w| ..)` method takes [ev_enable::W](ev_enable::W) writer structure" ]
impl crate :: Writable for EV_ENABLE { } # [ doc = "" ]
pub mod ev_enable { # [ doc = "Reader of register EV_ENABLE" ]
pub type R = crate :: R < u32 , super :: EV_ENABLE > ; # [ doc = "Writer for register EV_ENABLE" ]
pub type W = crate :: W < u32 , super :: EV_ENABLE > ; # [ doc = "Register EV_ENABLE `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: EV_ENABLE { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `enable`" ]
pub type ENABLE_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `enable`" ]
pub struct ENABLE_W < 'a > { w : & 'a mut W , } impl < 'a > ENABLE_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x03 ) | ( ( value as u32 ) & 0x03 ) ; self . w } } impl R { # [ doc = "Bits 0:1" ]
# [ inline ( always ) ]
pub fn enable ( & self ) -> ENABLE_R { ENABLE_R :: new ( ( self . bits & 0x03 ) as u8 ) } } impl W { # [ doc = "Bits 0:1" ]
# [ inline ( always ) ]
pub fn enable ( & mut self ) -> ENABLE_W { ENABLE_W { w : self } } } } # [ doc = "\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [xover_rxtx](xover_rxtx) module" ]
pub type XOVER_RXTX = crate :: Reg < u32 , _XOVER_RXTX > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _XOVER_RXTX ; # [ doc = "`read()` method returns [xover_rxtx::R](xover_rxtx::R) reader structure" ]
impl crate :: Readable for XOVER_RXTX { } # [ doc = "`write(|w| ..)` method takes [xover_rxtx::W](xover_rxtx::W) writer structure" ]
impl crate :: Writable for XOVER_RXTX { } # [ doc = "" ]
pub mod xover_rxtx { # [ doc = "Reader of register XOVER_RXTX" ]
pub type R = crate :: R < u32 , super :: XOVER_RXTX > ; # [ doc = "Writer for register XOVER_RXTX" ]
pub type W = crate :: W < u32 , super :: XOVER_RXTX > ; # [ doc = "Register XOVER_RXTX `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: XOVER_RXTX { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `xover_rxtx`" ]
pub type XOVER_RXTX_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `xover_rxtx`" ]
pub struct XOVER_RXTX_W < 'a > { w : & 'a mut W , } impl < 'a > XOVER_RXTX_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xff ) | ( ( value as u32 ) & 0xff ) ; self . w } } impl R { # [ doc = "Bits 0:7" ]
# [ inline ( always ) ]
pub fn xover_rxtx ( & self ) -> XOVER_RXTX_R { XOVER_RXTX_R :: new ( ( self . bits & 0xff ) as u8 ) } } impl W { # [ doc = "Bits 0:7" ]
# [ inline ( always ) ]
pub fn xover_rxtx ( & mut self ) -> XOVER_RXTX_W { XOVER_RXTX_W { w : self } } } } # [ doc = "\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [xover_txfull](xover_txfull) module" ]
pub type XOVER_TXFULL = crate :: Reg < u32 , _XOVER_TXFULL > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _XOVER_TXFULL ; # [ doc = "`read()` method returns [xover_txfull::R](xover_txfull::R) reader structure" ]
impl crate :: Readable for XOVER_TXFULL { } # [ doc = "" ]
pub mod xover_txfull { # [ doc = "Reader of register XOVER_TXFULL" ]
pub type R = crate :: R < u32 , super :: XOVER_TXFULL > ; # [ doc = "Reader of field `xover_txfull`" ]
pub type XOVER_TXFULL_R = crate :: R < bool , bool > ; impl R { # [ doc = "Bit 0" ]
# [ inline ( always ) ]
pub fn xover_txfull ( & self ) -> XOVER_TXFULL_R { XOVER_TXFULL_R :: new ( ( self . bits & 0x01 ) != 0 ) } } } # [ doc = "\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [xover_rxempty](xover_rxempty) module" ]
pub type XOVER_RXEMPTY = crate :: Reg < u32 , _XOVER_RXEMPTY > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _XOVER_RXEMPTY ; # [ doc = "`read()` method returns [xover_rxempty::R](xover_rxempty::R) reader structure" ]
impl crate :: Readable for XOVER_RXEMPTY { } # [ doc = "" ]
pub mod xover_rxempty { # [ doc = "Reader of register XOVER_RXEMPTY" ]
pub type R = crate :: R < u32 , super :: XOVER_RXEMPTY > ; # [ doc = "Reader of field `xover_rxempty`" ]
pub type XOVER_RXEMPTY_R = crate :: R < bool , bool > ; impl R { # [ doc = "Bit 0" ]
# [ inline ( always ) ]
pub fn xover_rxempty ( & self ) -> XOVER_RXEMPTY_R { XOVER_RXEMPTY_R :: new ( ( self . bits & 0x01 ) != 0 ) } } } # [ doc = "\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [xover_ev_status](xover_ev_status) module" ]
pub type XOVER_EV_STATUS = crate :: Reg < u32 , _XOVER_EV_STATUS > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _XOVER_EV_STATUS ; # [ doc = "`read()` method returns [xover_ev_status::R](xover_ev_status::R) reader structure" ]
impl crate :: Readable for XOVER_EV_STATUS { } # [ doc = "`write(|w| ..)` method takes [xover_ev_status::W](xover_ev_status::W) writer structure" ]
impl crate :: Writable for XOVER_EV_STATUS { } # [ doc = "" ]
pub mod xover_ev_status { # [ doc = "Reader of register XOVER_EV_STATUS" ]
pub type R = crate :: R < u32 , super :: XOVER_EV_STATUS > ; # [ doc = "Writer for register XOVER_EV_STATUS" ]
pub type W = crate :: W < u32 , super :: XOVER_EV_STATUS > ; # [ doc = "Register XOVER_EV_STATUS `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: XOVER_EV_STATUS { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `xover_ev_status`" ]
pub type XOVER_EV_STATUS_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `xover_ev_status`" ]
pub struct XOVER_EV_STATUS_W < 'a > { w : & 'a mut W , } impl < 'a > XOVER_EV_STATUS_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x03 ) | ( ( value as u32 ) & 0x03 ) ; self . w } } impl R { # [ doc = "Bits 0:1" ]
# [ inline ( always ) ]
pub fn xover_ev_status ( & self ) -> XOVER_EV_STATUS_R { XOVER_EV_STATUS_R :: new ( ( self . bits & 0x03 ) as u8 ) } } impl W { # [ doc = "Bits 0:1" ]
# [ inline ( always ) ]
pub fn xover_ev_status ( & mut self ) -> XOVER_EV_STATUS_W { XOVER_EV_STATUS_W { w : self } } } } # [ doc = "\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [xover_ev_pending](xover_ev_pending) module" ]
pub type XOVER_EV_PENDING = crate :: Reg < u32 , _XOVER_EV_PENDING > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _XOVER_EV_PENDING ; # [ doc = "`read()` method returns [xover_ev_pending::R](xover_ev_pending::R) reader structure" ]
impl crate :: Readable for XOVER_EV_PENDING { } # [ doc = "`write(|w| ..)` method takes [xover_ev_pending::W](xover_ev_pending::W) writer structure" ]
impl crate :: Writable for XOVER_EV_PENDING { } # [ doc = "" ]
pub mod xover_ev_pending { # [ doc = "Reader of register XOVER_EV_PENDING" ]
pub type R = crate :: R < u32 , super :: XOVER_EV_PENDING > ; # [ doc = "Writer for register XOVER_EV_PENDING" ]
pub type W = crate :: W < u32 , super :: XOVER_EV_PENDING > ; # [ doc = "Register XOVER_EV_PENDING `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: XOVER_EV_PENDING { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `xover_ev_pending`" ]
pub type XOVER_EV_PENDING_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `xover_ev_pending`" ]
pub struct XOVER_EV_PENDING_W < 'a > { w : & 'a mut W , } impl < 'a > XOVER_EV_PENDING_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x03 ) | ( ( value as u32 ) & 0x03 ) ; self . w } } impl R { # [ doc = "Bits 0:1" ]
# [ inline ( always ) ]
pub fn xover_ev_pending ( & self ) -> XOVER_EV_PENDING_R { XOVER_EV_PENDING_R :: new ( ( self . bits & 0x03 ) as u8 ) } } impl W { # [ doc = "Bits 0:1" ]
# [ inline ( always ) ]
pub fn xover_ev_pending ( & mut self ) -> XOVER_EV_PENDING_W { XOVER_EV_PENDING_W { w : self } } } } # [ doc = "\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [xover_ev_enable](xover_ev_enable) module" ]
pub type XOVER_EV_ENABLE = crate :: Reg < u32 , _XOVER_EV_ENABLE > ; # [ allow ( missing_docs ) ]
# [ doc ( hidden ) ]
pub struct _XOVER_EV_ENABLE ; # [ doc = "`read()` method returns [xover_ev_enable::R](xover_ev_enable::R) reader structure" ]
impl crate :: Readable for XOVER_EV_ENABLE { } # [ doc = "`write(|w| ..)` method takes [xover_ev_enable::W](xover_ev_enable::W) writer structure" ]
impl crate :: Writable for XOVER_EV_ENABLE { } # [ doc = "" ]
pub mod xover_ev_enable { # [ doc = "Reader of register XOVER_EV_ENABLE" ]
pub type R = crate :: R < u32 , super :: XOVER_EV_ENABLE > ; # [ doc = "Writer for register XOVER_EV_ENABLE" ]
pub type W = crate :: W < u32 , super :: XOVER_EV_ENABLE > ; # [ doc = "Register XOVER_EV_ENABLE `reset()`'s with value 0" ]
impl crate :: ResetValue for super :: XOVER_EV_ENABLE { type Type = u32 ; # [ inline ( always ) ]
fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `xover_ev_enable`" ]
pub type XOVER_EV_ENABLE_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `xover_ev_enable`" ]
pub struct XOVER_EV_ENABLE_W < 'a > { w : & 'a mut W , } impl < 'a > XOVER_EV_ENABLE_W < 'a > { # [ doc = r"Writes raw bits to the field" ]
# [ inline ( always ) ]
pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x03 ) | ( ( value as u32 ) & 0x03 ) ; self . w } } impl R { # [ doc = "Bits 0:1" ]
# [ inline ( always ) ]
pub fn xover_ev_enable ( & self ) -> XOVER_EV_ENABLE_R { XOVER_EV_ENABLE_R :: new ( ( self . bits & 0x03 ) as u8 ) } } impl W { # [ doc = "Bits 0:1" ]
# [ inline ( always ) ]
pub fn xover_ev_enable ( & mut self ) -> XOVER_EV_ENABLE_W { XOVER_EV_ENABLE_W { w : self } } } } } # [ no_mangle ]
static mut DEVICE_PERIPHERALS : bool = false ; # [ doc = r"All the peripherals" ]
# [ allow ( non_snake_case ) ]
pub struct Peripherals { # [ doc = "TIMER0" ]
pub TIMER0 : TIMER0 , # [ doc = "IDENTIFIER_MEM" ]
pub IDENTIFIER_MEM : IDENTIFIER_MEM , # [ doc = "MEMLCD" ]
pub MEMLCD : MEMLCD , # [ doc = "CTRL" ]
pub CTRL : CTRL , # [ doc = "SIMSTATUS" ]
pub SIMSTATUS : SIMSTATUS , # [ doc = "SRAM_EXT" ]
pub SRAM_EXT : SRAM_EXT , # [ doc = "UART" ]
pub UART : UART , } impl Peripherals { # [ doc = r"Returns all the peripherals *once*" ]
# [ inline ]
pub fn take ( ) -> Option < Self > { riscv :: interrupt :: free ( | _ | { if unsafe { DEVICE_PERIPHERALS } { None } else { Some ( unsafe { Peripherals :: steal ( ) } ) } } ) } # [ doc = r"Unchecked version of `Peripherals::take`" ]
# [ inline ]
pub unsafe fn steal ( ) -> Self { DEVICE_PERIPHERALS = true ; Peripherals { TIMER0 : TIMER0 { _marker : PhantomData } , IDENTIFIER_MEM : IDENTIFIER_MEM { _marker : PhantomData } , MEMLCD : MEMLCD { _marker : PhantomData } , CTRL : CTRL { _marker : PhantomData } , SIMSTATUS : SIMSTATUS { _marker : PhantomData } , SRAM_EXT : SRAM_EXT { _marker : PhantomData } , UART : UART { _marker : PhantomData } , } } }